

# 前缀函数&KMP算法

---

## 前缀函数

### 定义

给定一个长度为 $n$ 的字符串序列 $s$ ，其 **前缀函数** 被定义为一个长度为 $n$ 的数组 $\pi$, 其中 $\pi$ 的定义为：

     　　1. 如果字串 $s$ 有一对相等的真前缀 $s[0 \dots k-1]$ 与真后缀 $s[i-(k-1) \dots i]$, 那么pi[i]就是这个相等的真前缀或者是真后缀（因为他们相等）的长度, 也就是$\pi[i] = k$.
     　　2. 如果不止有一对相等的, 那么$\pi[i]$就是其中最长的那一对的长度.
     　　3. 如果没有相等的, 那么 $\pi[i] = 0$ .

简单来说 $\pi[i]$ 就是: 字串 $s[0···i]$ 最长的相等的真前缀与真后缀的长度.

特别地, 规定$\pi[0] = 0$.

举例来说, 对于字符串`abcabcd`:

$\pi[0] = 0$, 因为`a`没有真前缀和真后缀, 规定为 $0$.

$\pi[1] = 1$, 因为`ab`无相等的真前缀和真后缀.

$\pi[2] = 0$, 因为`abc`无相等的真前缀和真后缀.

$\pi[3] = 1$, 因为`abca`只有一对相等的真前缀和真后缀: `a`, 长度为 $1$.

$\pi[4] = 2$, 因为`abcab`只有一对相等的真前缀和真后缀: `ab`, 长度为 $2$.

$\pi[5] = 3$, 因为`abcabc`只有一对相等的真前缀和真后缀: `abc`, 长度为 $3$.

$\pi[6] = 0$, 因为`abcabcd`无相等的真前缀和真后缀.

同理可以计算字符串`aabaaab`的前缀函数为 $[0, 1, 0, 1, 2, 2, 3]$.

### 朴素算法

一个直接按照定义来计算前缀和的算法流程

　　· 在一个循环中以 $i=1$ ~ $n-1$ 的顺序计算前缀函数 $\pi[i]$ 的值( $\pi[0]$ 被赋值为 $0$ ).
　　· 为了计算当前的前缀函数值 $\pi[i]$ , 我们令循环变量$j$从最大的真前缀长度 $i$ 开始尝试.
　　· 如果当下真前缀和真后缀相等, 则此时长度 $\pi[i]$ 为 $j$ .
　　· 如果 $j = 0$ 并且没有任何一次匹配, 则置 $\pi[i]=0$ 并移至下一个下标 $i+1$.

具体实现如下:

```cpp
void pref(string s)
{
    int ln = (int)s.length();
    for(int i = 1; i < n; i++)
        for(int j = i; j; j--)
            if(s.substr(0, j) == s.substr(i-j+1, j))
                {
                    pi[i] = j;
                    break;
                }
```



### 计算前缀数组高效的算法

- **优化一**

首先，我们观察到, **相邻的前缀函数至多增加 $1$**.

所以当移动到下一个位置的时候, 前缀函数的值最多只能增加 $1$.

此时改进的算法为:

```cpp
void pref(string s)
{
    int ln = (int)s.length();
    for(int i = 1; i < n; i++)
        for(int j = pi[i-1]+1; j; j--)
            if(s.substr(0, j) == s.substr(i-j+1, j))
                {
                    pi[i] = j;
                    break;
                }
```

经过此次改进，时间复杂度由 $O(n^3)$ 降为了 $O(n^2)$.

- **优化二**

在优化一中，我们讨论了计算 $\pi[i+1]$ 时的最好情况：$s[i+1] = s[\pi[i]]$，此时 $\pi[i+1] = \pi[i] + 1$。现在让我们沿着此思路走得更远一些，讨论：当 $s[i+1] \neq s[\pi[i]]$ 时该如何跳转。

失配时，我们希望找到对于字串 $s[0 \dots i]$，仅次于 $\pi[i]$ 的第二长度 $j$，使得在位置 $i$ 的前缀性质得以保持，也即 $s[0 \dots j-1] = s[i-j+1 \dots 0]$，
$$
\overbrace{\underbrace{s_0 ~ s_1}_j ~ s_1 ~ s_3}^{\pi[i]} ~ \dots ~ \overbrace{s_{i-3} ~ s_{i-2} ~ \underbrace{s_{i-1} ~ s_{i}}_j}^{\pi[i]} ~ s_{i+1}
$$
