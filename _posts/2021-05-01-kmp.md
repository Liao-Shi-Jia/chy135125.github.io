---
layout:     post
title:      前缀函数 & KMP算法
subtitle:   高效的字符串匹配算法
date:       2021-05-01
author:     Chy12321
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - 字符串
---

# 前缀函数 & KMP算法

---

## 前缀函数

### 定义

给定一个长度为 $n$ 的字符串序列 $s$，其 **前缀函数** 被定义为一个长度为 $n$ 的数组 $\pi$，其中 $\pi$ 的定义为：

1. 如果字串 $s$ 有一对相等的真前缀 $s[0 \dots k-1]$ 与真后缀 $s[i-(k-1) \dots i]$，那么pi[i]就是这个相等的真前缀或者是真后缀（因为他们相等）的长度，也就是$\pi[i] = k$.  
2. 如果不止有一对相等的，那么$\pi[i]$就是其中最长的那一对的长度.
3. 如果没有相等的，那么 $\pi[i] = 0$. 简单来说 $\pi[i]$ 就是: 字串 $s[0···i]$ 最长的相等的真前缀与真后缀的长度.

特别地, 规定$\pi[0] = 0$.

举例来说，对于字符串`abcabcd`:

* $\pi[0] = 0$, 因为`a`没有真前缀和真后缀, 规定为 $0$.
* $\pi[1] = 1$, 因为`ab`无相等的真前缀和真后缀.
* $\pi[2] = 0$, 因为`abc`无相等的真前缀和真后缀.
* $\pi[3] = 1$, 因为`abca`只有一对相等的真前缀和真后缀: `a`, 长度为 $1$.
* $\pi[4] = 2$, 因为`abcab`只有一对相等的真前缀和真后缀: `ab`, 长度为 $2$.
* $\pi[5] = 3$, 因为`abcabc`只有一对相等的真前缀和真后缀: `abc`, 长度为 $3$.
* $\pi[6] = 0$, 因为`abcabcd`无相等的真前缀和真后缀.

同理可以计算字符串`aabaaab`的前缀函数为 $[0, 1, 0, 1, 2, 2, 3]$.

### 朴素算法

一个直接按照定义来计算前缀和的算法流程

* 在一个循环中以 $i=1$ ~ $n-1$ 的顺序计算前缀函数 $\pi[i]$ 的值( $\pi[0]$ 被赋值为 $0$ ).
* 为了计算当前的前缀函数值 $\pi[i]$，我们令循环变量$j$从最大的真前缀长度 $i$ 开始尝试.
*  如果当下真前缀和真后缀相等，则此时长度 $\pi[i]$ 为 $j$ .
*  如果 $j = 0$ 并且没有任何一次匹配，则置 $\pi[i]=0$ 并移至下一个下标 $i+1$.

具体实现如下:

```cpp
void pref(string s)
{
    int ln = (int)s.length();
    for(int i = 1; i < n; i++)
        for(int j = i; j; j--)
            if(s.substr(0, j) == s.substr(i-j+1, j))
                {
                    pi[i] = j;
                    break;
                }
```

显然，该算法的时间复杂度为 $O(n^3)$，还有很大优化空间. 

### 计算前缀数组高效的算法

**优化一**

首先，我们观察到，**相邻的前缀函数至多增加 $1$**.

所以当移动到下一个位置的时候，前缀函数的值最多只能增加 $1$.

此时改进的算法为:

```cpp
void pref(string s)
{
    int ln = (int)s.length();
    for(int i = 1; i < n; i++)
        for(int j = pi[i-1]+1; j; j--)
            if(s.substr(0, j) == s.substr(i-j+1, j))
                {
                    pi[i] = j;
                    break;
                }
```

经过此次改进，时间复杂度由 $O(n^3)$ 降为了 $O(n^2)$.

**优化二**

在优化一中，我们讨论了计算 $\pi[i+1]$ 时的最好情况：$s[i+1] = s[\pi[i]]$，此时 $\pi[i+1] = \pi[i] + 1$. 现在让我们沿着此思路走得更远一些，讨论：当 $s[i+1] \neq s[\pi[i]]$ 时该如何跳转. 

失配时，我们希望找到对于字串 $s[0 \dots i]$，仅次于 $\pi[i]$ 的第二长度 $j$，使得在位置 $i$ 的前缀性质得以保持，也即 $s[0 \dots j-1] = s[i-j+1 \dots 0]$：


$$
\overbrace{\underbrace{s_0 ~ s_1}_j ~ s_1 ~ s_3}^{\pi[i]} ~ \dots ~ \overbrace{s_{i-3} ~ s_{i-2} ~ \underbrace{s_{i-1} ~ s_{i}}_j}^{\pi[i]} ~ s_{i+1}
$$


如果我们找到了这样的长度 $j$，那么仅需再次比较 $s[i+1]$ 和 $s[j]$. 如果它们相等，那么就有 $\pi[i+1] = j+1$. 否则，我们需要找到字串 $s[0 \dots i]$ 仅次于 $j$ 的第二长度 $j^{(2)}$，使得前缀性质得以保持. 如此往复，直到 $j = 0$。如果 $s[i+1] \neq s[0]$，则 $\pi[i+1] = 0$. 

观察上图可以发现，因为 $s[0 \dots \pi[i]-1] = s[i-\pi[i]+1 \dots i]$，所以对于 $s[0 \dots i]$ 的第二长度 $j$，有这样的性质：


$$
s[0 \dots j-1] = s[i-j+1 \dots i] = s[\pi[i]-j \dots \pi[i]-1]
$$


也就是说 $j$ 等价于子串 $s[\pi[i]-1]$ 的前缀函数值，即 $j = \pi[\pi[i]-1]$. 同理，次于 $j$ 的第二长度等价于 $s[j-1]$ 的前缀函数值，即 $j^{(2)} = \pi[j-1]$. 

显然我们可以得到一个关于 $j$ 的状态转移方程：$j^{(n)} = \pi[j^{(n-1)}-1],(j{(n-1)} > 0)$. 

### 最终算法

所以最终我们可以构建一个只进行 $O(n)$ 次操作的算法，而且此算法的实现出人意料地短且直观：

```cpp
void pref(string s)
{
    int n = (int)s.length();
    for(int i = 1, j; i < n; i++)
    {
        j = pi[i-1];
        while(s[i] != s[j] && j > 0) j = pi[j-1];
        if(s[i] == s[j]) j++;
        pi[i] = j;
    }
}
```

这是一个 **在线** 算法，即一边读入一边处理. 
举例来说，你可以一个字符一个字符地读取字符串，并立即处理它们以计算出每一个字符的前缀函数值。

该算法仍然需要存储字符串本身以及先前计算过的函数值，但如果我们已经预知了该字符串的最大可能取值 $M$，那么我们仅仅需要存储字符串的前 $M+1$ 个字符及其对应的前缀函数值. 

---

## Knuth-Morris-Pratt(KMP) 算法

该算法由Kunth、Pratt、和Morris在1977年共同发布. 

该任务是前缀函数的一个典型应用. 

给定一个文本 $t$ 和一个字符串 $s$，我们尝试找到并展示 $s$ 在 $t$ 中的所有出现. 

为了简便起见，我们用 $n$ 来表示文本 $t$ 的长度，用 $m$ 来表示字符串 $s$ 的长度. 

我们构造一个字符串 $s + C = t$，其中 $C$ 为一个既不出现在 $s$ 也不出现在 $t$ 中的分隔符.
接下来计算该函数的前缀函数. 现在考虑该前缀函数除去最开始的 $n + 1$ 个值（即属于字符串 $s$ 和分隔符 $C$ 的函数值）后其余函数值的意义. 



## 参考资料

本文主要参考资料为OI-WiKi上的[前缀函数与KMP算法](https://oi-wiki.org/string/kmp/).